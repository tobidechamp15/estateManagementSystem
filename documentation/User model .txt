# Setting Up an Auth System for an Estate Management System in Next.js with MongoDB

Here's a comprehensive guide to implementing an authentication system for your estate management web app where users access their profiles using a code provided by the estate management.

## System Overview

1. **Pre-registration**: Estate management pre-enters user details (fullName, email, phone, address)
2. **Access Flow**: 
   - User enters access code
   - System checks if profile is activated (has password)
   - Redirects to login if activated, signup if not

## Step 1: Set Up MongoDB Schema

First, define your user schema in MongoDB:

```javascript
// models/User.js
import mongoose from 'mongoose';

const userSchema = new mongoose.Schema({
  accessCode: {
    type: String,
    required: true,
    unique: true
  },
  fullName: {
    type: String,
    required: true
  },
  email: {
    type: String,
    required: true,
    unique: true
  },
  phone: {
    type: String,
    required: true
  },
  address: {
    type: String,
    required: true
  },
  password: {
    type: String,
    required: false // Initially not required until activation
  },
  isActive: {
    type: Boolean,
    default: false
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

export default mongoose.models.User || mongoose.model('User', userSchema);
```

## Step 2: Create API Endpoints

### 1. Check Access Code Endpoint

```javascript
// pages/api/auth/check-code.js
import User from '../../../models/User';
import dbConnect from '../../../utils/dbConnect';

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  await dbConnect();

  const { accessCode } = req.body;

  try {
    const user = await User.findOne({ accessCode });
    
    if (!user) {
      return res.status(404).json({ message: 'Invalid access code' });
    }

    // Check if user has set password (is activated)
    if (user.password) {
      return res.status(200).json({ 
        exists: true,
        email: user.email,
        message: 'Account exists, please login'
      });
    } else {
      return res.status(200).json({ 
        exists: false,
        userData: {
          fullName: user.fullName,
          email: user.email,
          phone: user.phone,
          address: user.address
        },
        message: 'Please set your password to activate account'
      });
    }
  } catch (error) {
    return res.status(500).json({ message: 'Server error' });
  }
}
```

### 2. Signup/Activation Endpoint

```javascript
// pages/api/auth/signup.js
import User from '../../../models/User';
import dbConnect from '../../../utils/dbConnect';
import bcrypt from 'bcryptjs';

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  await dbConnect();

  const { accessCode, password } = req.body;

  try {
    // Find user by access code
    const user = await User.findOne({ accessCode });
    
    if (!user) {
      return res.status(404).json({ message: 'Invalid access code' });
    }

    // Check if user already activated
    if (user.password) {
      return res.status(400).json({ message: 'Account already activated' });
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 12);

    // Update user with password and activate
    user.password = hashedPassword;
    user.isActive = true;
    await user.save();

    return res.status(200).json({ 
      message: 'Account activated successfully',
      email: user.email
    });
  } catch (error) {
    return res.status(500).json({ message: 'Server error' });
  }
}
```

### 3. Login Endpoint

```javascript
// pages/api/auth/login.js
import User from '../../../models/User';
import dbConnect from '../../../utils/dbConnect';
import bcrypt from 'bcryptjs';

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  await dbConnect();

  const { email, password } = req.body;

  try {
    const user = await User.findOne({ email });
    
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Check if password matches
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    // Here you would typically create a session or JWT token
    // For simplicity, we'll just return success
    return res.status(200).json({ 
      message: 'Login successful',
      user: {
        id: user._id,
        fullName: user.fullName,
        email: user.email,
        phone: user.phone,
        address: user.address
      }
    });
  } catch (error) {
    return res.status(500).json({ message: 'Server error' });
  }
}
```

## Step 3: Create Frontend Components

### 1. Access Code Verification Page

```javascript
// pages/access-code.js
import { useState } from 'react';
import { useRouter } from 'next/router';

export default function AccessCodeVerification() {
  const [accessCode, setAccessCode] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const router = useRouter();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      const response = await fetch('/api/auth/check-code', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ accessCode }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || 'Something went wrong');
      }

      if (data.exists) {
        // Redirect to login with email pre-filled
        router.push(`/login?email=${encodeURIComponent(data.email)}`);
      } else {
        // Redirect to signup with user data
        router.push({
          pathname: '/signup',
          query: {
            accessCode,
            ...data.userData
          }
        });
      }
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <h1>Enter Your Access Code</h1>
      <form onSubmit={handleSubmit}>
        <input
          type="text"
          value={accessCode}
          onChange={(e) => setAccessCode(e.target.value)}
          placeholder="Enter access code"
          required
        />
        <button type="submit" disabled={loading}>
          {loading ? 'Verifying...' : 'Continue'}
        </button>
        {error && <p style={{ color: 'red' }}>{error}</p>}
      </form>
    </div>
  );
}
```

### 2. Signup/Activation Page

```javascript
// pages/signup.js
import { useState } from 'react';
import { useRouter } from 'next/router';

export default function Signup() {
  const router = useRouter();
  const {
    accessCode,
    fullName,
    email,
    phone,
    address
  } = router.query;

  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (password !== confirmPassword) {
      setError('Passwords do not match');
      return;
    }

    setLoading(true);
    setError('');

    try {
      const response = await fetch('/api/auth/signup', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ accessCode, password }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || 'Activation failed');
      }

      // Redirect to login with email pre-filled
      router.push(`/login?email=${encodeURIComponent(email)}`);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <h1>Activate Your Account</h1>
      <p>Welcome, {fullName}</p>
      
      <form onSubmit={handleSubmit}>
        <div>
          <label>Email:</label>
          <input type="email" value={email} readOnly />
        </div>
        
        <div>
          <label>Password:</label>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
          />
        </div>
        
        <div>
          <label>Confirm Password:</label>
          <input
            type="password"
            value={confirmPassword}
            onChange={(e) => setConfirmPassword(e.target.value)}
            required
          />
        </div>
        
        <button type="submit" disabled={loading}>
          {loading ? 'Activating...' : 'Activate Account'}
        </button>
        
        {error && <p style={{ color: 'red' }}>{error}</p>}
      </form>
    </div>
  );
}
```

### 3. Login Page

```javascript
// pages/login.js
import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';

export default function Login() {
  const router = useRouter();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  useEffect(() => {
    // Pre-fill email if coming from access code or signup
    if (router.query.email) {
      setEmail(router.query.email);
    }
  }, [router.query.email]);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ email, password }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || 'Login failed');
      }

      // Here you would typically store the auth token and redirect to dashboard
      router.push('/dashboard');
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <h1>Login</h1>
      
      <form onSubmit={handleSubmit}>
        <div>
          <label>Email:</label>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
        </div>
        
        <div>
          <label>Password:</label>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
          />
        </div>
        
        <button type="submit" disabled={loading}>
          {loading ? 'Logging in...' : 'Login'}
        </button>
        
        {error && <p style={{ color: 'red' }}>{error}</p>}
      </form>
    </div>
  );
}
```

## Step 4: Admin Panel for Pre-registering Users

Create an admin panel where estate management can pre-register users:

```javascript
// pages/admin/add-user.js
import { useState } from 'react';

export default function AddUser() {
  const [formData, setFormData] = useState({
    fullName: '',
    email: '',
    phone: '',
    address: '',
    accessCode: ''
  });
  const [loading, setLoading] = useState(false);
  const [success, setSuccess] = useState(false);

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);

    try {
      const response = await fetch('/api/admin/add-user', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData),
      });

      if (!response.ok) {
        throw new Error('Failed to add user');
      }

      setSuccess(true);
      setFormData({
        fullName: '',
        email: '',
        phone: '',
        address: '',
        accessCode: ''
      });
    } catch (error) {
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <h1>Add New User</h1>
      {success && <p style={{ color: 'green' }}>User added successfully!</p>}
      
      <form onSubmit={handleSubmit}>
        <div>
          <label>Full Name:</label>
          <input
            type="text"
            name="fullName"
            value={formData.fullName}
            onChange={handleChange}
            required
          />
        </div>
        
        <div>
          <label>Email:</label>
          <input
            type="email"
            name="email"
            value={formData.email}
            onChange={handleChange}
            required
          />
        </div>
        
        <div>
          <label>Phone:</label>
          <input
            type="text"
            name="phone"
            value={formData.phone}
            onChange={handleChange}
            required
          />
        </div>
        
        <div>
          <label>Address:</label>
          <input
            type="text"
            name="address"
            value={formData.address}
            onChange={handleChange}
            required
          />
        </div>
        
        <div>
          <label>Access Code:</label>
          <input
            type="text"
            name="accessCode"
            value={formData.accessCode}
            onChange={handleChange}
            required
          />
        </div>
        
        <button type="submit" disabled={loading}>
          {loading ? 'Adding...' : 'Add User'}
        </button>
      </form>
    </div>
  );
}
```

With corresponding API endpoint:

```javascript
// pages/api/admin/add-user.js
import User from '../../../models/User';
import dbConnect from '../../../utils/dbConnect';

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  // Add admin authentication check here in production

  await dbConnect();

  const { fullName, email, phone, address, accessCode } = req.body;

  try {
    // Check if email or access code already exists
    const existingUser = await User.findOne({ 
      $or: [{ email }, { accessCode }] 
    });

    if (existingUser) {
      return res.status(400).json({ 
        message: 'Email or access code already exists' 
      });
    }

    // Create new user
    const newUser = new User({
      fullName,
      email,
      phone,
      address,
      accessCode,
      isActive: false
    });

    await newUser.save();

    return res.status(201).json({ 
      message: 'User pre-registered successfully',
      user: newUser
    });
  } catch (error) {
    return res.status(500).json({ message: 'Server error' });
  }
}
```

## Step 5: Security Considerations

1. **Password Hashing**: Always hash passwords before storing (using bcrypt as shown)
2. **HTTPS**: Ensure your app uses HTTPS in production
3. **Rate Limiting**: Implement rate limiting on auth endpoints
4. **Session Management**: Use secure HTTP-only cookies for sessions
5. **Input Validation**: Validate all user inputs on server side
6. **Access Code Generation**: Generate secure, random access codes

## Step 6: Deployment Considerations

1. **Environment Variables**: Store sensitive data (database URLs, secrets) in environment variables
2. **Database Connection**: Use connection pooling for MongoDB
3. **Error Handling**: Implement proper error handling and logging
4. **Monitoring**: Set up monitoring for your auth system

This implementation provides a complete flow from pre-registration by estate management to user activation and login. You can extend it with additional features like password reset, email verification, or two-factor authentication as needed.